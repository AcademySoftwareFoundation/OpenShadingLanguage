/* Copyright Contributors to the Open Shading Language project.
 * SPDX-License-Identifier: BSD-3-Clause
 * https://github.com/AcademySoftwareFoundation/OpenShadingLanguage
 */


/** Lexical scanner for Open Shading Language
 **/

%top{
/* Include this first to avoid warnings about re-definitions on windows */
#include <stdint.h>
}

/************************************************************
 * Definitions section
 ************************************************************/

%option reentrant bison-bridge
%option extra-type="OSL::pvt::OSLCompilerImpl *"

/* Option 'noyywrap' indicates that when EOF is hit, yyin does not
 * automatically reset to another file.
 */
%option noyywrap
%option nounput noinput

/* never-interactive fixes a Windows compatibility problem where the
 * lexer emits isatty calls that don't exist.
 */
%option never-interactive

 /* Option 'prefix' creates a C++ lexer with the given prefix, so that
  * we can link with other flex-generated lexers in the same application
  * without name conflicts.
  */
%option prefix="osl"


 /* Define regular expression macros
  ************************************************/

 /* white space, not counting newline */
WHITE           [ \t\v\f\r]+
 /* alpha character */
ALPHA           [A-Za-z]
 /* numerals */
DIGIT           [0-9]
 /* Integer literal */
INTEGER         {DIGIT}+
HEXINTEGER      0[xX][0-9a-fA-F]+
 /* floating point literal (E, FLT1, FLT2, FLT3 are just helpers)
  * NB: we don't allow leading +/- due to ambiguity between
  * whether "a-0.5" is really "a -0.5" or "a - 0.5".  Resolve this
  * in the grammar.
  */
E               [eE][-+]?{DIGIT}+
FLT1            {DIGIT}+\.{DIGIT}*{E}?
FLT2            {DIGIT}*\.{DIGIT}+{E}?
FLT3            {DIGIT}+{E}
FLT             {FLT1}|{FLT2}|{FLT3}
 /* string literal */
STR     \"(\\.|[^\\"\n])*\"
        /* " This extra quote fixes emacs syntax highlighting on this file */
 /* Identifier: alphanumeric, may contain digits after the first character */
IDENT           ({ALPHA}|[_])({ALPHA}|{DIGIT}|[_])*
 /* C preprocessor (cpp) directives */
CPP             ^[ \t]*#.*\n
CPLUSCOMMENT    \/\/.*\n



 /* Note for lex newbies: the following '%{ .. %}' section contains literal
  * C code that will be inserted at the top of code that flex generates.
  */
%{
#include <climits>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <string>

#include <OpenImageIO/thread.h>
#include <OpenImageIO/strutil.h>
#include "oslcomp_pvt.h"

using namespace OSL;
using namespace OSL::pvt;

#include "oslgram.hpp"   /* Generated by bison/yacc */

#define YY_USER_ACTION \
    oslcompiler->update_srcloc(&yyloc_param->first_line, &yyloc_param->first_column, \
                               &yyloc_param->last_line,  &yyloc_param->last_column, yytext);


#ifdef _WIN32
#define YY_NO_UNISTD_H

#ifdef _MSC_VER
#define strtoll _strtoi64
#include <io.h>
#define isatty _isatty
#endif
#endif

// flex itself will generate fatal warnings about signed vs unsigned.
// Bypass that nonsense.
OSL_GCC_ONLY_PRAGMA(GCC diagnostic ignored "-Wsign-compare")

// flex uses the 'register' keyword, warned because it's deprecated in C++17.
OSL_CLANG_PRAGMA(GCC diagnostic ignored "-Wdeprecated-register")
OSL_CLANG_PRAGMA(GCC diagnostic ignored "-Wregister")
OSL_GCC_ONLY_PRAGMA(GCC diagnostic ignored "-Wregister")

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC visibility push(hidden)
#endif

OSL_NAMESPACE_BEGIN
namespace pvt {
    void preprocess (const char *str, OSLCompilerImpl* oslcompiler, YYLTYPE* yyloc_param);
    int osllex(YYSTYPE* yylval_param, YYLTYPE* yyloc_param, void* yyscanner, OSLCompilerImpl* oslcompiler);
}
OSL_NAMESPACE_END
#define YY_DECL int OSL::pvt::osllex(YYSTYPE* yylval_param, YYLTYPE* yyloc_param, void* yyscanner, OSLCompilerImpl* oslcompiler)

%}

%%

 /************************************************
  * Lexical matching rules
  ************************************************/

 /* preprocessor symbols */
{CPP}                   {  OSL::pvt::preprocess (yytext, oslcompiler, yyloc_param); }

 /* Comments */
{CPLUSCOMMENT}          {  /* nothing to do, skip the comment */ }

 /* keywords */
"break"                 { return (yylval->i=BREAK); }
"closure"               { return (yylval->i=CLOSURE); }
"color"                 { return (yylval->i=COLORTYPE); }
"continue"              { return (yylval->i=CONTINUE); }
"do"                    { return (yylval->i=DO); }
"else"                  { return (yylval->i=ELSE); }
"float"                 { return (yylval->i=FLOATTYPE); }
"for"                   { return (yylval->i=FOR); }
"if"                    { return (yylval->i=IF_TOKEN); }
"illuminance"           { return (yylval->i=ILLUMINANCE); }
"illuminate"            { return (yylval->i=ILLUMINATE); }
"int"                   { return (yylval->i=INTTYPE); }
"matrix"                { return (yylval->i=MATRIXTYPE); }
"normal"                { return (yylval->i=NORMALTYPE); }
"output"                { return (yylval->i=OUTPUT); }
"point"                 { return (yylval->i=POINTTYPE); }
"public"                { return (yylval->i=PUBLIC); }
"return"                { return (yylval->i=RETURN); }
"string"                { return (yylval->i=STRINGTYPE); }
"struct"                { return (yylval->i=STRUCT); }
"vector"                { return (yylval->i=VECTORTYPE); }
"void"                  { return (yylval->i=VOIDTYPE); }
"while"                 { return (yylval->i=WHILE); }
"or"                    { return (yylval->i=OR_OP); }
"and"                   { return (yylval->i=AND_OP); }
"not"                   { return (yylval->i=NOT_OP); }

 /* reserved words */
"bool"|"case"|"char"|"class"|"const"|"default"|"double" |    \
"enum"|"extern"|"false"|"friend"|"inline"|"long"|"private" | \
"protected"|"short"|"signed"|"sizeof"|"static"|"struct" |    \
"switch"|"template"|"this"|"true"|"typedef"|"uniform" |      \
"union"|"unsigned"|"varying"|"virtual" {
                            oslcompiler->errorfmt(oslcompiler->srcloc(),
                                                  "'{}' is a reserved word",
                                                  yytext);
                            return (yylval->i=RESERVED);
                        }


 /* Identifiers */
{IDENT}                 {
                            yylval->s = ustring(yytext).c_str();
                            return IDENTIFIER;
                        }

 /* Literal values */
{INTEGER}               {
                            long long llval = strtoll (yytext, (char**)NULL, 10);
                            // we do not detect overflow when the value is INT_MAX+1,
                            // because negation happens later and -(INT_MAX+1) == INT_MIN
                            if (llval > ((long long)INT_MAX)+1) {
                                oslcompiler->errorfmt(oslcompiler->srcloc(),
                                                      "integer overflow, value must be between {} and {}.",
                                                      INT_MIN, INT_MAX);
                            }
                            yylval->i = (int)llval;
                            return INT_LITERAL;
                        }
{HEXINTEGER}            {
                            long long llval = strtoll (yytext, (char**)NULL, 16);
                            // we do not detect overflow when the value is INT_MAX+1,
                            // because negation happens later and -(INT_MAX+1) == INT_MIN
                            if (llval > ((long long)UINT_MAX)+1) {
                                oslcompiler->errorfmt(oslcompiler->srcloc(),
                                                      "integer overflow, value must be between {} and {}.",
                                                      INT_MIN, INT_MAX);
                            }
                            yylval->i = (int)llval;
                            return INT_LITERAL;
                        }



{FLT}                   {
                            yylval->f = OIIO::Strutil::from_string<float>(yytext);
                            return FLOAT_LITERAL;
                        }

{STR}                   {
                            // grab the material between the quotes
                            string_view s(yytext + 1, yyleng - 2);
                            std::string unescaped;
                            if (s.find('\\') != string_view::npos) {
                                // Only make a new string if we must unescape
                                unescaped = OIIO::Strutil::unescape_chars(s);
                                s = string_view(unescaped);
                            }
                            yylval->s = ustring(s).c_str();
                            // std::cerr << "osllex string '" << yylval->s << "'\n";
                            return STRING_LITERAL;
                        }

 /* The one-char operators (like "+") will return correctly with the
  * catch-all rule, but we need to define the two-character operators
  * so they are not lexed as '+' and '=' separately, for example.
  */
"+="                    { return (yylval->i=ADD_ASSIGN); }
"-="                    { return (yylval->i=SUB_ASSIGN); }
"*="                    { return (yylval->i=MUL_ASSIGN); }
"/="                    { return (yylval->i=DIV_ASSIGN); }
"&="                    { return (yylval->i=BIT_AND_ASSIGN); }
"|="                    { return (yylval->i=BIT_OR_ASSIGN); }
"^="                    { return (yylval->i=XOR_ASSIGN); }
"<<="                   { return (yylval->i=SHL_ASSIGN); }
">>="                   { return (yylval->i=SHR_ASSIGN); }
"<<"                    { return (yylval->i=SHL_OP); }
">>"                    { return (yylval->i=SHR_OP); }
"&&"                    { return (yylval->i=AND_OP); }
"||"                    { return (yylval->i=OR_OP); }
"<="                    { return (yylval->i=LE_OP); }
">="                    { return (yylval->i=GE_OP); }
"=="                    { return (yylval->i=EQ_OP); }
"!="                    { return (yylval->i=NE_OP); }
"++"                    { return (yylval->i=INCREMENT); }
"--"                    { return (yylval->i=DECREMENT); }

 /* Beginning of metadata */
"[["                    { return (yylval->i=METADATA_BEGIN); }

 /* End of line */
"\\\n"                  |
[\n]                    {  }

 /* Ignore whitespace */
{WHITE}                 {  }

 /* catch-all rule for any other single characters */
!                       { return (yylval->i = NOT_OP); }
.                       { return (yylval->i = *yytext); }

%%

OSL_NAMESPACE_BEGIN
namespace pvt {   // OSL::pvt

void
preprocess (const char *str, OSLCompilerImpl* oslcompiler, YYLTYPE* yyloc_param)
{
#if 0
    printf ("preprocess: <%s>\n", str);
#endif
    const char *p = str;
    while (*p == ' ' || *p == '\t')
        p++;
    if (*p != '#') {
        oslcompiler->errorfmt(oslcompiler->srcloc(),
                              "Possible bug in shader preprocess");
        return;
    }
    p++;
    while (*p == ' ' || *p == '\t')
        p++;
    if (! strncmp (p, "pragma", 6)) {
        // pragma
        OIIO::string_view line (p+6);
        string_view pragmatype = OIIO::Strutil::parse_word (line);
        if (pragmatype == "error") {
            string_view msg;
            if (OIIO::Strutil::parse_string(line, msg))
                oslcompiler->errorfmt(oslcompiler->srcloc(), "{}", msg);
            else
                oslcompiler->errorfmt(oslcompiler->srcloc(),
                                      "<unknown error>");
        }
        else if (pragmatype == "warning") {
            string_view msg;
            if (OIIO::Strutil::parse_string(line, msg))
                oslcompiler->warningfmt(oslcompiler->srcloc(), "{}", msg);
            else
                oslcompiler->warningfmt(oslcompiler->srcloc(),
                                        "<unknown warning>");
        }
        else if (OIIO::Strutil::iequals (pragmatype, "osl")) {
            string_view pragmaname = OIIO::Strutil::parse_word (line);
            if (pragmaname == "nowarn") {
                oslcompiler->pragma_nowarn ();
            } else {
                oslcompiler->warningfmt(oslcompiler->srcloc(),
                                        "Unknown pragma '{}'", pragmaname);
            }
        }
        // N.B. Any other pragmas that don't start with "osl" are ignored
        // the pragma ends with an EOLN
        yyloc_param->last_line++;
        yyloc_param->last_column = 0;
        oslcompiler->update_srcloc(&yyloc_param->first_line, &yyloc_param->first_column,
                                   &yyloc_param->last_line,  &yyloc_param->last_column, str);
    } else {  /* probably the line number and filename */
        if (! strncmp (p, "line", 4))
            p += 4;
        int line = atoi (p);
        if (line > 0) {
            const char *f = strchr (str, '\"'); // " undo syntax highlight
            if (f) {
                ++f;  // increment to past the quote
                int len = 0;  // count of chars within quotes
                while (f[len] && f[len] != '\"') // " undo syntax highlight
                    ++len;
                std::string filename (f, len);
                // Make it relative to the working directory, so error output
                // isn't hugely cluttered (and also to make the preprocessor's
                // error output match the standard cpp.
                if (filename.find (oslcompiler->cwd()) == 0) {
                    filename.erase (0, oslcompiler->cwd().size());
                    if (filename.size() &&
                        (filename[0] == '/' || filename[0] == '\\'))
                        filename.erase (0, 1);
                }
                ustring ufilename(filename);
                oslcompiler->update_filename(ufilename);
                // TODO: We no longer use Boost Wave, so verify if the
                // workaround below is still needed ..
                // Spooky workaround for Boost Wave bug: force_include
                // is broken and doesn't give us the right lines/files, so
                // instead we forcefully insert a '#include "stdosl.h"' into
                // the stream ourselves, but this in turn makes the rest
                // of the main file all have line counts one line off!
                // So we fix it here, ugh.
                if (ufilename == oslcompiler->main_filename())
                    --line;
            }
            yyloc_param->last_line = line-1;
            yyloc_param->last_column = 0;
            oslcompiler->update_srcloc(&yyloc_param->first_line, &yyloc_param->first_column,
                                       &yyloc_param->last_line,  &yyloc_param->last_column, str);

        } else {
            oslcompiler->errorfmt(oslcompiler->srcloc(),
                                  "Unrecognized preprocessor command: #{}", p);
        }
    }
}

static std::mutex oslcompiler_mutex;

bool
OSLCompilerImpl::osl_parse_buffer (const std::string &preprocessed_buffer)
{
    // Thread safety with the lexer/parser
    std::lock_guard<std::mutex> lock(oslcompiler_mutex);

    yyscan_t scanner;
    yylex_init(&scanner);
    YY_BUFFER_STATE buffer = yy_scan_string(preprocessed_buffer.c_str(), scanner);
    yy_switch_to_buffer (buffer, scanner);
    oslparse (scanner, this);
    bool parseerr = error_encountered();
    yy_delete_buffer (buffer, scanner);
    yylex_destroy(scanner);

    return parseerr;
}

}; // namespace pvt
OSL_NAMESPACE_END

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC visibility pop
#endif
